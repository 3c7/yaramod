import json
import getopt
import os
import sys


def chunked(seq, chunk_size):
    i = 0
    while chunk := seq[i:i+chunk_size]:
        yield chunk
        i += chunk_size


def escapeString(s):
    result = ""
    for c in s:
        if c == "\"":
            result += "\\\""
        elif c == "\\":
            result += "\\\\"
        elif not (0x20 <= ord(c) < 0x7f):
            result += f"\\x{ord(c):02x}"
        else:
            result += c
    return result


def main(argv):
    input_directory = ""
    output_directory = ""
    try:
        opts, args = getopt.getopt(argv, "hi:o:", ["ifile=", "ofile="])
    except getopt.GetoptError:
        print("ERROR: Bad arguments for json_to_array.py: -i <input_directory> -o <output_directory>")
        sys.exit(2)

    for opt, arg in opts:
        if opt == "-h":
            print("json_to_array.py -i <input_directory> -o <output_directory>")
            sys.exit()
        elif opt in ("-i", "--ifile"):
            input_directory = arg
        elif opt in ("-o", "--ofile"):
            output_directory = arg

    if not input_directory or not output_directory:
        print("ERROR: Bad arguments for json_to_array.py: Both <input_directory> and <output_directory> must be specified.")
        sys.exit(2)

    module_names = []

    for file in os.listdir(input_directory):
        filename, extension = os.path.splitext(file)
        if extension != ".json":
            continue
        source_path = os.path.join(input_directory, file)
        output_file = os.path.join(output_directory, filename + "_generated.h")

        with open(source_path, "r") as f:
            data = json.load(f)

        if "name" not in data:
            continue
        module_name = data["name"]
        module_names.append(filename)

        module_content = json.dumps(data)
        module_content_chunks = [f"\"{escapeString(chunk)}\"" for chunk in chunked(module_content, 1024)]
        module_content_chunks_str = ',\n'.join(module_content_chunks)

        with open(output_file, "w") as f:
            f.write(f"""/**
 * @file modules/generated/module_{module_name}_generated.h
 * @brief Definition of {filename} written in array. Generated by json_to_array.py
 * @copyright (c) 2021 Avast Software, licensed under the MIT license
 */
 #pragma once

 #include "yaramod/types/modules/module_content.h"

 namespace yaramod {{

 namespace modules {{

 class G{filename} : public ModuleContent
 {{
 public:
    static constexpr std::size_t module_content_size = {len(module_content) + 1};
    static constexpr const char* module_content_parts[] = {{
{module_content_chunks_str}
    }};

    G{filename}() : ModuleContent("{module_name}")
    {{
        std::string content;
        content.reserve(module_content_size);
        for (std::size_t i = 0; i < {len(module_content_chunks)}; ++i)
            content += module_content_parts[i];
        setContent(std::move(content));
    }}
 }};

 }} // namespace modules

 }} // namespace yaramod
""")

    includes = '\n'.join([f"#include \"{m}_generated.h\"" for m in module_names])
    classes = ', '.join([f"G{m}{{}}" for m in module_names])
    list_file = os.path.join(output_directory, "module_list.h")
    with open(list_file, "w") as f:
        f.write(f"""/**
* @file modules/generated/module_list.h
* @brief File containing includes of generated module files. Generated by json_to_array.py
* @copyright (c) 2021 Avast Software, licensed under the MIT license
*/
#pragma once

#include <vector>

#include "yaramod/types/modules/module_content.h"

{includes}


namespace yaramod {{

namespace modules {{

class ModuleList
{{
public:
    std::vector<ModuleContent> list = {{ {classes} }};
}};

}} // namespace modules

}} // namespace yaramod
""")

if __name__ == "__main__":
    main(sys.argv[1:])
